# Дженеріки

Дженеріки допомагають писати універсальний код без втрати точності типів.

---

## 🎯 Мета уроку
Після цього уроку ти зможеш:
- створювати generic-функції
- будувати generic-інтерфейси
- застосовувати обмеження `extends`
- типізувати reusable-утиліти для проєкту

---

## 🧠 Теорія

### Generic-функції
```ts
function identity<T>(value: T): T {
  return value;
}
```

---

### Generic-інтерфейси
```ts
interface ApiResponse<T> {
  success: boolean;
  data: T;
}
```

---

### Обмеження типів
```ts
function getId<T extends { id: number }>(item: T): number {
  return item.id;
}
```

---
### Глибше про універсальні абстракції
Дженеріки дають можливість описати один механізм для багатьох типів даних: пагінація, результати API, репозиторії, кеші. Це особливо цінно у великих кодових базах, де дублювання швидко перетворюється на технічний борг.

Головне правило — не робити дженеріки "занадто розумними": краще простий прозорий generic-контракт, ніж складна конструкція, яку важко читати.

## 💻 Практичний приклад

```ts
interface Paginated<T> {
  items: T[];
  total: number;
}

function firstItem<T>(data: Paginated<T>): T | null {
  return data.items.length ? data.items[0] : null;
}

const courses = firstItem({ items: [{ id: 1, title: "TS" }], total: 1 });
console.log(courses);
```

---

## 📝 Підсумки
- дженеріки зменшують дублювання типів
- обмеження забезпечують контроль контракту
- generic-підхід добре масштабується в великих кодових базах
