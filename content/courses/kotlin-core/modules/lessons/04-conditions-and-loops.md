# Умови та цикли

Керування потоком у Kotlin виразне: `if` і `when` повертають значення, а цикли працюють з діапазонами та колекціями.

---

## 🎯 Мета уроку
Після цього уроку ти зможеш:
- писати умови через `if` та `when`
- використовувати `for`, `while`, `do while`
- працювати з діапазонами `..`, `until`, `downTo`
- обирати найбільш читабельний варіант конструкції

---

## 🧠 Теорія

### `if` як вираз
```kotlin
val age = 19
val access = if (age >= 18) "allowed" else "denied"
```

---

### `when` для гілок логіки
```kotlin
fun grade(score: Int): String = when {
    score >= 90 -> "A"
    score >= 75 -> "B"
    score >= 60 -> "C"
    else -> "D"
}
```

---

### Цикли і діапазони
```kotlin
for (i in 1..3) println(i)
for (i in 5 downTo 1) println(i)
```

---
### Глибше про читабельність умов
Умовні конструкції швидко ускладнюються, коли змішується бізнес-логіка, перевірки доступів і валідація вхідних даних. Практика показує, що краще виносити складні умови в окремі функції з говорящими назвами.

Такий підхід зменшує вкладеність, спрощує тестування і дозволяє повторно використовувати перевірки в різних частинах застосунку.

## 💻 Практичний приклад

```kotlin
fun main() {
    val tasks = listOf("Read", "Code", "Test")

    for ((index, task) in tasks.withIndex()) {
        val priority = if (index == 0) "high" else "normal"
        println("${index + 1}. $task [$priority]")
    }
}
```

---

## 📝 Підсумки
- `when` часто читається краще за довгі `if-else`
- діапазони роблять цикли короткими і зрозумілими
- вибір конструкції впливає на підтримуваність коду
